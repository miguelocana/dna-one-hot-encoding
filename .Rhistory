break
}
}
for (k in 1:length(seq_sepseq)) {
ind <- grep(paste(sepseq_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_sepseq[k]
}
}
print('BIEN 4')
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con los nucleótidos separados en columnas diferentes
return (df3)
}
df_nb <- sepseq(df=promoters, col_seq = 'V3')
sepseq <- function (df, col_seq, sepseq_cols_name='N', remove_col_seq = FALSE) {
# Se asegura de que todas las seq tengan el mismo tamaño (de lo contrario salta ERROR)
f <- length(strsplit(df[col_seq][[1]], "")[[1]])
for (j in 1:nrow(df)) {
a = length(strsplit(df[j,col_seq], "")[[1]])
if (a == f) {
next
} else {
print('ERROR: al menos una secuencia no tiene el mismo tamaño que el resto.')
break
}
}
# Crea una columna por cada nucleotido
num_cols <- f
cols_sepseq <- list()
for (i in 1:num_cols) {
cols_sepseq <- append(cols_sepseq,paste(sepseq_cols_name,i,sep=""))
}
# Añade las columnas (vacías) al nuevo DF
df2 <- df
for (i in cols_sepseq) {
df2[,i] <- NA
}
print(cols_sepseq)
print('BIEN 3')
# Traducción de seq a one-hot encoding
for (j in 1:nrow(df2)) {
seq = strsplit(tolower(df2[j,col_seq]), "")[[1]] # convierte la seq en minuscula
seq_sepseq <- list()
for (i in seq) {
if ((i == 'a') | (i == 'g') | (i == 'c') | (i == 't')) {
seq_onehot <- append(seq_sepseq, i)
} else {
print("ERROR: al menos un carácter de la secuencia introducida no corresponde a ningún nucleótido (A,G,C,T).")
break
}
}
for (k in 1:length(seq_sepseq)) {
ind <- grep(paste(sepseq_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_sepseq[k]
}
}
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con los nucleótidos separados en columnas diferentes
return (df3)
}
df_nb <- sepseq(df=promoters, col_seq = 'V3')
sepseq <- function (df, col_seq, sepseq_cols_name='N', remove_col_seq = FALSE) {
# Se asegura de que todas las seq tengan el mismo tamaño (de lo contrario salta ERROR)
f <- length(strsplit(df[col_seq][[1]], "")[[1]])
for (j in 1:nrow(df)) {
a = length(strsplit(df[j,col_seq], "")[[1]])
if (a == f) {
next
} else {
print('ERROR: al menos una secuencia no tiene el mismo tamaño que el resto.')
break
}
}
# Crea una columna por cada nucleotido
num_cols <- f
cols_sepseq <- list()
for (i in 1:num_cols) {
cols_sepseq <- append(cols_sepseq,paste(sepseq_cols_name,i,sep=""))
}
# Añade las columnas (vacías) al nuevo DF
df2 <- df
for (i in cols_sepseq) {
df2[,i] <- NA
}
print('BIEN 3')
print(nrow(df2))
# Traducción de seq a one-hot encoding
for (j in 1:nrow(df2)) {
seq = strsplit(tolower(df2[j,col_seq]), "")[[1]] # convierte la seq en minuscula
seq_sepseq <- list()
for (i in seq) {
if ((i == 'a') | (i == 'g') | (i == 'c') | (i == 't')) {
seq_onehot <- append(seq_sepseq, i)
} else {
print("ERROR: al menos un carácter de la secuencia introducida no corresponde a ningún nucleótido (A,G,C,T).")
break
}
}
for (k in 1:length(seq_sepseq)) {
ind <- grep(paste(sepseq_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_sepseq[k]
}
}
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con los nucleótidos separados en columnas diferentes
return (df3)
}
df_nb <- sepseq(df=promoters, col_seq = 'V3')
sepseq <- function (df, col_seq, sepseq_cols_name='N', remove_col_seq = FALSE) {
# Se asegura de que todas las seq tengan el mismo tamaño (de lo contrario salta ERROR)
f <- length(strsplit(df[col_seq][[1]], "")[[1]])
for (j in 1:nrow(df)) {
a = length(strsplit(df[j,col_seq], "")[[1]])
if (a == f) {
next
} else {
print('ERROR: al menos una secuencia no tiene el mismo tamaño que el resto.')
break
}
}
# Crea una columna por cada nucleotido
num_cols <- f
cols_sepseq <- list()
for (i in 1:num_cols) {
cols_sepseq <- append(cols_sepseq,paste(sepseq_cols_name,i,sep=""))
}
# Añade las columnas (vacías) al nuevo DF
df2 <- df
for (i in cols_sepseq) {
df2[,i] <- NA
}
print('BIEN 3')
# Traducción de seq a one-hot encoding
for (j in 1:nrow(df2)) {
seq = strsplit(tolower(df2[j,col_seq]), "")[[1]] # convierte la seq en minuscula
seq_sepseq <- list()
for (i in seq) {
if ((i == 'a') | (i == 'g') | (i == 'c') | (i == 't')) {
seq_sepseq <- append(seq_sepseq, i)
} else {
print("ERROR: al menos un carácter de la secuencia introducida no corresponde a ningún nucleótido (A,G,C,T).")
break
}
}
for (k in 1:length(seq_sepseq)) {
ind <- grep(paste(sepseq_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_sepseq[k]
}
}
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con los nucleótidos separados en columnas diferentes
return (df3)
}
df_nb <- sepseq(df=promoters, col_seq = 'V3')
View(df_nb)
df_nb <- sepseq(df=promoters[,-2], col_seq = 'V3')
sepseq <- function (df, col_seq, sepseq_cols_name='N', remove_col_seq = FALSE) {
# Se asegura de que todas las seq tengan el mismo tamaño (de lo contrario salta ERROR)
f <- length(strsplit(df[col_seq][[1]], "")[[1]])
for (j in 1:nrow(df)) {
a = length(strsplit(df[j,col_seq], "")[[1]])
if (a == f) {
next
} else {
print('ERROR: al menos una secuencia no tiene el mismo tamaño que el resto.')
break
}
}
# Crea una columna por cada nucleotido
num_cols <- f
cols_sepseq <- list()
for (i in 1:num_cols) {
cols_sepseq <- append(cols_sepseq,paste(sepseq_cols_name,i,sep=""))
}
# Añade las columnas (vacías) al nuevo DF
df2 <- df
for (i in cols_sepseq) {
df2[,i] <- NA
}
# Traducción de seq a one-hot encoding
for (j in 1:nrow(df2)) {
seq = strsplit(tolower(df2[j,col_seq]), "")[[1]] # convierte la seq en minuscula
seq_sepseq <- list()
for (i in seq) {
if ((i == 'a') | (i == 'g') | (i == 'c') | (i == 't')) {
seq_sepseq <- append(seq_sepseq, i)
} else {
print("ERROR: al menos un carácter de la secuencia introducida no corresponde a ningún nucleótido (A,G,C,T).")
break
}
}
for (k in 1:length(seq_sepseq)) {
ind <- grep(paste(sepseq_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_sepseq[k]
}
}
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con los nucleótidos separados en columnas diferentes
return (df3)
}
df_nb <- sepseq(df=promoters[,-2], col_seq = 'V3')
View(df_nb)
df_nb <- sepseq(df=promoters[,-2], col_seq = 'V3', remove_col_seq = TRUE)
View(df_nb)
###################################### CÓDIGO ##########################################
onehot <- function (df, col_seq, onehot_cols_name='H', remove_col_seq = FALSE) {
# Se asegura de que todas las seq tengan el mismo tamaño (de lo contrario salta ERROR)
f <- length(strsplit(df[col_seq][[1]], "")[[1]])
for (j in 1:nrow(df)) {
a = length(strsplit(df[j,col_seq], "")[[1]])
if (a == f) {
next
} else {
print('ERROR: al menos una secuencia no tiene el mismo tamaño que el resto.')
break
}
}
# Crea una columna por cada dígito del one-hot
num_cols <- f * 4
cols_onehot <- list()
for (i in 1:num_cols) {
cols_onehot <- append(cols_onehot,paste(onehot_cols_name,i,sep=""))
}
# Añade las columnas (vacías) al nuevo DF
df2 <- df
for (i in cols_onehot) {
df2[,i] <- NA
}
# Traducción de seq a one-hot encoding
for (j in 1:nrow(df2)) {
seq = strsplit(tolower(df2[j,col_seq]), "")[[1]] # convierte la seq en minuscula
seq_onehot <- list()
for (i in seq) {
if (i == 'a') {
seq_onehot <- append(seq_onehot, c(0,0,0,1))
} else if (i == 'g') {
seq_onehot <- append(seq_onehot, c(0,0,1,0))
} else if (i == 'c') {
seq_onehot <- append(seq_onehot, c(0,1,0,0))
} else if (i == 't') {
seq_onehot <- append(seq_onehot, c(1,0,0,0))
} else {
print("ERROR: al menos un carácter de la secuencia introducida no corresponde a ningún nucleótido (A,G,C,T).")
break
}
}
for (k in 1:length(seq_onehot)) {
ind <- grep(paste(onehot_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_onehot[k]
}
}
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con one-hot encoding
return (df3)
}
sepseq <- function (df, col_seq, sepseq_cols_name='N', remove_col_seq = FALSE) {
# Se asegura de que todas las seq tengan el mismo tamaño (de lo contrario salta ERROR)
f <- length(strsplit(df[col_seq][[1]], "")[[1]])
for (j in 1:nrow(df)) {
a = length(strsplit(df[j,col_seq], "")[[1]])
if (a == f) {
next
} else {
print('ERROR: al menos una secuencia no tiene el mismo tamaño que el resto.')
break
}
}
# Crea una columna por cada nucleotido
num_cols <- f
cols_sepseq <- list()
for (i in 1:num_cols) {
cols_sepseq <- append(cols_sepseq,paste(sepseq_cols_name,i,sep=""))
}
# Añade las columnas (vacías) al nuevo DF
df2 <- df
for (i in cols_sepseq) {
df2[,i] <- NA
}
# Mueve cada nucleótido a su correspondiente columna
for (j in 1:nrow(df2)) {
seq = strsplit(tolower(df2[j,col_seq]), "")[[1]] # convierte la seq en minuscula
seq_sepseq <- list()
for (i in seq) {
if ((i == 'a') | (i == 'g') | (i == 'c') | (i == 't')) {
seq_sepseq <- append(seq_sepseq, i)
} else {
print("ERROR: al menos un carácter de la secuencia introducida no corresponde a ningún nucleótido (A,G,C,T).")
break
}
}
for (k in 1:length(seq_sepseq)) {
ind <- grep(paste(sepseq_cols_name,k,sep=""), colnames(df2))
df2[j,ind] <- seq_sepseq[k]
}
}
# Elimina o no la columna con la secuencia
if (remove_col_seq) {
df3 <- df2[,c(colnames(df2)[-grep(col_seq, colnames(df2))])]
} else {
df3 <- df2
}
# Devuelve el df con los nucleótidos separados en columnas diferentes
return (df3)
}
split_train_test <- function(df, size = 0.7, seed = 123) {
# Establece la semilla
set.seed(seed)
# Devuelve un "diccionario" con el DF partido en train y test
t <- floor(size * nrow(df))
train_ind <- sample(seq_len(nrow(df)), size = t)
train <- df[train_ind,]
test <- df[-train_ind,]
# Quita la semilla
set.seed(Sys.time())
return (list('train' = train, 'test' = test))
}
str(df)
# Carga datos
promoters <- read.csv('promoters.txt',header = FALSE,sep=',')
df <- sepseq(df=promoters[,-2], col_seq = 'V3', remove_col_seq = TRUE)
df[,1] <- as.factor(df[,1])
str(df)
df[,:] <- as.factor(df[,:])
df[,1:] <- as.factor(df[,1:])
df[,2:ncol(df)] <- as.factor(df[,2:ncol(df)])
str(df)
df <- sepseq(df=promoters[,-2], col_seq = 'V3', remove_col_seq = TRUE)
for (i in 2:ncol(df)) {
df[,i] <- as.factor(df[,i])
}
str(df)
for (i in 1:ncol(df)) {
df[,i] <- as.factor(df[,i])
}
str(df)
# Split train y data
train <- split_train_test(df)$train[,-1]
test <- split_train_test(df)$test[,-1]
train_labels <- as.factor(split_train_test(df)$train[,1])
test_labels <- as.factor(split_train_test(df)$test[,1])
# Modelo y estadísticos
NB <- e1071::naiveBayes(train, train_labels, laplace = 0)
# Predicciones
pNB <- predict(NB, test)
# Predicciones
pNB <- predict(NB, test)
confusionMatrix(pNB, test_labels, dnn = c('Predicho','Actual'))
plot(pNB)
histogram(pNB)
# Laplace = 0
# Modelo y estadísticos
NBlp0 <- e1071::naiveBayes(train, train_labels, laplace = 0)
# Predicciones
pNBlp0 <- predict(NBlp0, test)
confusionMatrix(pNBlp0, test_labels, dnn = c('Predicho','Actual'))
# Laplace = 1
# Modelo y estadísticos
NBlp1 <- e1071::naiveBayes(train, train_labels, laplace = 1)
# Predicciones
pNBlp1 <- predict(NBlp1, test)
confusionMatrix(pNBlp1, test_labels, dnn = c('Predicho','Actual'))
a <- confusionMatrix(pNBlp1, test_labels, dnn = c('Predicho','Actual'))
a$dots
a$positive
a$table
a$overall
a$overall[1]
naive_bayes <- function (df_categorica) {
# Transforma todas las columnas en factores
for (i in 1:ncol(df)) {
df[,i] <- as.factor(df[,i])
}
# Split train y data
train <- split_train_test(df)$train[,-1]
test <- split_train_test(df)$test[,-1]
train_labels <- as.factor(split_train_test(df)$train[,1])
test_labels <- as.factor(split_train_test(df)$test[,1])
# Laplace = 0
# Modelo y estadísticos
NBlp0 <- e1071::naiveBayes(train, train_labels, laplace = 0)
# Predicciones
pNBlp0 <- predict(NBlp0, test)
c1 <- confusionMatrix(pNBlp0, test_labels, dnn = c('Predicho','Actual'))
# Interpretación final:
# - El modelo tiene una precisión del 90%
# - Devuelve 3 falsos negativos
# Laplace = 1
# Modelo y estadísticos
NBlp1 <- e1071::naiveBayes(train, train_labels, laplace = 1)
# Predicciones
pNBlp1 <- predict(NBlp1, test)
c2 <- confusionMatrix(pNBlp1, test_labels, dnn = c('Predicho','Actual'))
# Interpretación final:
# - El modelo tiene una precisión del 84%
# - Devuelve 2 falsos positivos
# - Devuelve 1 falso negativo
return (list('NBlp0'=c1, 'NBlp1'=c2,))
}
a <- naive_bayes(df)
a <- naive_bayes(df)$NBlp0
naive_bayes <- function (df_categorica) {
# Transforma todas las columnas en factores
for (i in 1:ncol(df)) {
df[,i] <- as.factor(df[,i])
}
# Split train y data
train <- split_train_test(df)$train[,-1]
test <- split_train_test(df)$test[,-1]
train_labels <- as.factor(split_train_test(df)$train[,1])
test_labels <- as.factor(split_train_test(df)$test[,1])
# Laplace = 0
# Modelo y estadísticos
NBlp0 <- e1071::naiveBayes(train, train_labels, laplace = 0)
# Predicciones
pNBlp0 <- predict(NBlp0, test)
c1 <- confusionMatrix(pNBlp0, test_labels, dnn = c('Predicho','Actual'))
# Interpretación final:
# - El modelo tiene una precisión del 90%
# - Devuelve 3 falsos negativos
# Laplace = 1
# Modelo y estadísticos
NBlp1 <- e1071::naiveBayes(train, train_labels, laplace = 1)
# Predicciones
pNBlp1 <- predict(NBlp1, test)
c2 <- confusionMatrix(pNBlp1, test_labels, dnn = c('Predicho','Actual'))
# Interpretación final:
# - El modelo tiene una precisión del 84%
# - Devuelve 2 falsos positivos
# - Devuelve 1 falso negativo
return (list('NBlp0'=c1, 'NBlp1'=c2))
}
a <- naive_bayes(df)
a$NBlp0
str(df_categorica[,1])
str(df[,1])
str(df[,1]) == factor()
is.factor(df[,1])
naive_bayes <- function (df_categorica) {
# Transforma todas las columnas en factores
for (i in 1:ncol(df)) {
# Comprueba si es factor, de lo contrario lo transforma
if (is.factor(df[,i])) {
next
} else {
df[,i] <- as.factor(df[,i])
}
}
# Split train y data
train <- split_train_test(df)$train[,-1]
test <- split_train_test(df)$test[,-1]
train_labels <- as.factor(split_train_test(df)$train[,1])
test_labels <- as.factor(split_train_test(df)$test[,1])
# Laplace = 0
# Modelo y estadísticos
NBlp0 <- e1071::naiveBayes(train, train_labels, laplace = 0)
# Predicciones
pNBlp0 <- predict(NBlp0, test)
c1 <- confusionMatrix(pNBlp0, test_labels, dnn = c('Predicho','Actual'))
# Interpretación final:
# - El modelo tiene una precisión del 90%
# - Devuelve 3 falsos negativos
# Laplace = 1
# Modelo y estadísticos
NBlp1 <- e1071::naiveBayes(train, train_labels, laplace = 1)
# Predicciones
pNBlp1 <- predict(NBlp1, test)
c2 <- confusionMatrix(pNBlp1, test_labels, dnn = c('Predicho','Actual'))
# Interpretación final:
# - El modelo tiene una precisión del 84%
# - Devuelve 2 falsos positivos
# - Devuelve 1 falso negativo
return (list('NBlp0'=c1, 'NBlp1'=c2))
}
a <- naive_bayes(df)
a$NBlp0
runApp('app')
runApp('app.R')
shiny::runApp('app.R')
setwd("C:/Users/migue/OneDrive/repositorios/dna-one-hot-encoding")
shiny::runApp('app.R')
install.packages("shinydashboard")
shiny::runApp('app.R')
